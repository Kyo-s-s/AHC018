# Kyo-s-s/AHC018

AHC018のコードです。
`make run`を叩くとたくさん実行してくれます。

## 考察メモ

### 1日目

- C++のサンプルを移植、Pythonでたくさん実行できるように
    ```
    500/500
    total: 261194177
    max: (2193816, '0187')
    ave: 522388.354
    min: (8383, '0347')
    ```

- とりあえず最小全域木みたいなのを作る、マンハッタン距離を重みとする + 毎回100ずつ叩く
    実行時間が見たいのでとりあえず提出 -> https://atcoder.jp/contests/ahc018/submissions/38965863 14,764,704 点
    ローカルだと遅い(TL5sを越える)ことがあったが、意外と大丈夫(Testerが重い？) 
    ```
    500/500
    total: 145620533
    max: (1453500, '0187')
    ave: 291241.066
    min: (8383, '0347')
    ```

- Cが128とかで100ずつ叩くのはバカなので、とりあえず`max(100, C * 5)`ずつ叩くように
    ```
    500/500
    total: 141921365
    max: (1017600, '0187')
    ave: 283842.73
    min: (8383, '0347')
    ```

- 隣接するGridの耐久値をメモ -> 耐久値がいくつかを推定するみたいなことをしたい
- そもそもNが高々200なので、グリッドで情報をもってBFSしながらやればよい？

### 2日目
- グリッドで情報を持って、N*NのUnionFindをもってやる を実装する！
    - 詳細詰める
    - 水源は高々4つなので、連結か？をそれぞれ見ればよい

- 隣接マスの差
    - 平均99, 最大791(seed = 0000)
    - 平均57, 最大620(seed = 0001)
    - 平均98, 最大759(seed = 0002)
    隣のマスが分かれば大体推定できる！
    - `IO`で破壊済マスを合計powerいくつで破壊したか？をメモ